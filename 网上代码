栈实现表达式计算【数据结构】
思路：

所包含的运算符有‘+’，‘-’，‘*’，‘/’，‘（’，‘）’。

（1）建立两个栈，一个用来存储操作数，另一个用来存储运算符, 开始时在运算符栈中先压入‘/0’，一个表达式的结束符。

（2）然后从左至右依次读取表达式中的各个符号（操作数或者运算符）；

（3）如果读到的是操作数直接存入操作数栈；

（4）如果读到的是运算符，则作进一步判断：

若读到的是‘/0’结束符，而且此时运算符栈的栈顶元素也是‘/0’结束符，则运算结束，输出操作数栈中的元素即为最后结果。

若读到的是‘（’或者读到的运算符的优先级比目前的运算符栈中的栈顶元素的优先级高，则将运算符直接存入运算符栈，继续读表达式中的下一个符号，重复步骤（3）和（4）；

若读到的是‘)’,而且此时运算符栈的栈顶元素是‘(’结束符，则将运算符栈中的栈顶元素退出来，继续读表达式中的下一个符号，重复步骤（3）和（4）；

若读到的运算符的优先级等于或小于之前的运算符的优先级，则从操作数中退出2个，从运算符中退出一个进行运算，将运算结果存入操作数栈；再把之前读到的运算符与目前的运算符栈顶比较，重复步骤（4）（即现在不读下一个元素）；

 #include <iostream>
#include <stack>
using namespace std;

double toNum(char*s, int &k)
{
	int flag = 0;
	double x = 0.0, y = 0.1;
	while (s[k] >= '0'&&s[k] <= '9' || s[k] == '.')
	{
		if (s[k] >= '0'&&s[k] <= '9')
		{
			if (flag == 0)
				x = x * 10 + s[k] - '0';
			else
			{
				x = x + y*(s[k] - '0');
				y = y*0.1;
			}
		}
		else
		{
			flag = 1;
		}
		k = k + 1;
	}
	return x;
}

int priority(char c)
{
	int k;
	switch (c)
	{
	case '*':k = 2; break;
	case '/':k = 2; break;
	case '+':k = 1; break;
	case '-':k = 1; break;
	case '(':k = 0; break;
	case ')':k = 0; break;
	default:k = -1; break;
	}
	return k;
}

int main()
{
	stack<double> sv;
	stack<char> sp;
	char c;
	int k = 0, flag = 1;
	double x, y;
	sp.push('\0');
	char *s = new char[100];
	cout << "请输入算式：" << endl;
	cin >> s;
	c = s[k];
	while (flag)
	{
		if (c >= '0'&&c <= '9' || c == '.')
		{
			sv.push(toNum(s, k));
		}
		else if (c == '\0'&& sp.top() == '\0')
		{
			flag = 0;
		}
		else if (c == '(' || (priority(c) > priority(sp.top())))
		{
			sp.push(c);
			k++;
		}
		else if (c == ')'&& sp.top() == '(')
		{
			sp.pop();
			k++;
		}
		else if (priority(c) <= priority(sp.top()))
		{
			x = sv.top();
			sv.pop();
			y = sv.top();
			sv.pop();
			c = sp.top();
			sp.pop();
			switch (c)
			{
			case '+':y = x + y; break;
			case '-':y = y - x; break;
			case '*':y = x*y; break;
			case '/':y = y / x; break;
			}
			sv.push(y);
		}
		c = s[k];
	}
	cout << sv.top() << endl;
	return 0;
}
